import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import os
import warnings

# Suppress all warnings
warnings.filterwarnings('ignore')

def load_and_process_application_data():
    """
    Load and minimally process application data
    """
    try:
        print("Loading applications data...")
        # Try different file name variations
        file_names = [
            'Applications_Renewals_by_Date_20250414.xlsx',
            'Applications_Renewals_by_Date_20250414.xls',
            'Applications Renewals by Date 20250414.xlsx',
            'Applications Renewals by Date 20250414.xls'
        ]
        
        df = None
        for file_name in file_names:
            if os.path.exists(file_name):
                print(f"Found file: {file_name}")
                df = pd.read_excel(file_name)
                break
        
        if df is None:
            print("Could not find applications data file.")
            return None
        
        print(f"Original data shape: {df.shape}")
        print(f"Original columns: {df.columns.tolist()}")
        
        # If first row looks like a header (contains 'date' or 'province')
        if any('date' in str(val).lower() for val in df.iloc[0]) or any('province' in str(val).lower() for val in df.iloc[0]):
            print("Using first row as header")
            header = df.iloc[0]
            df = df.iloc[1:].copy()
            df.columns = header
        
        # Find the date and province columns by name or position
        date_col = None
        for col in df.columns:
            if 'date' in str(col).lower():
                date_col = col
                break
        
        province_col = None
        for col in df.columns:
            if 'province' in str(col).lower() or 'prov' in str(col).lower():
                province_col = col
                break
        
        # If columns weren't found by name, try position-based assignment
        if date_col is None and len(df.columns) > 0:
            date_col = df.columns[0]  # Assume first column is date
        
        if province_col is None and len(df.columns) > 1:
            province_col = df.columns[1]  # Assume second column is province
        
        # Convert date to datetime
        if date_col:
            df[date_col] = pd.to_datetime(df[date_col], errors='coerce')
            # Drop rows with invalid dates
            df = df.dropna(subset=[date_col])
            print(f"Processed dates, remaining rows: {len(df)}")
        
        # Filter out 'Total' in province column
        if province_col:
            df = df[~df[province_col].astype(str).str.lower().isin(['total', 'totals'])]
            print(f"Filtered out 'Total' provinces, remaining rows: {len(df)}")
        
        # Don't attempt to convert numeric columns - use as is to avoid errors
        return df
    
    except Exception as e:
        print(f"Error in application data processing: {str(e)}")
        return None

def load_and_process_mailout_data():
    """
    Load and minimally process mailout data
    """
    try:
        print("\nLoading mailout data...")
        # Try different file name variations
        file_names = [
            'Mailout_Schedule.xlsx',
            'Mailout_Schedule.xls',
            'Mailout Schedule.xlsx',
            'Mailout Schedule.xls'
        ]
        
        df = None
        for file_name in file_names:
            if os.path.exists(file_name):
                print(f"Found file: {file_name}")
                df = pd.read_excel(file_name)
                break
        
        if df is None:
            print("Could not find mailout data file.")
            return None
        
        print(f"Original data shape: {df.shape}")
        print(f"Original columns: {df.columns.tolist()}")
        
        # Simple processing for a two-column file
        # Assume first column is date, second is mailout count
        if len(df.columns) >= 2:
            # Make a copy with just the first two columns
            simple_df = df.iloc[:, 0:2].copy()
            simple_df.columns = ['Date', 'Mailout']
            
            # Convert date to datetime
            simple_df['Date'] = pd.to_datetime(simple_df['Date'], errors='coerce')
            # Drop rows with invalid dates
            simple_df = simple_df.dropna(subset=['Date'])
            
            print(f"Processed mailout data, rows: {len(simple_df)}")
            return simple_df
        else:
            print("Mailout data doesn't have enough columns.")
            return None
    
    except Exception as e:
        print(f"Error in mailout data processing: {str(e)}")
        return None

def create_province_bar_chart(df):
    """
    Create a simple bar chart of applications by province
    """
    try:
        print("\nCreating province bar chart...")
        
        # Find the province column
        province_col = None
        for col in df.columns:
            if 'province' in str(col).lower() or 'prov' in str(col).lower():
                province_col = col
                break
        
        if province_col is None:
            print("Could not identify province column.")
            return
        
        # Find columns that might be renewal data
        data_cols = []
        for col in df.columns:
            col_str = str(col).lower()
            if 'renewal' in col_str or 'application' in col_str:
                if 'receiv' in col_str or 'complet' in col_str or 'elig' in col_str:
                    data_cols.append(col)
        
        # If we couldn't find specific columns, use numeric columns
        if not data_cols:
            print("Could not identify specific data columns. Using all numeric columns.")
            for col in df.columns:
                if col != province_col and col not in [c for c in df.columns if 'date' in str(c).lower()]:
                    # Check if column has numeric data
                    try:
                        pd.to_numeric(df[col], errors='raise')
                        data_cols.append(col)
                    except:
                        pass
        
        if not data_cols:
            print("No suitable data columns found for bar chart.")
            return
        
        # Select top 3 data columns for clarity
        if len(data_cols) > 3:
            data_cols = data_cols[:3]
        
        print(f"Using columns for bar chart: {data_cols}")
        
        # Group by province and sum the data columns
        try:
            # Convert to numeric first to avoid errors
            for col in data_cols:
                df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
            
            # Group by province - safely handling the operation
            grouped = df.groupby(province_col)[data_cols].sum().reset_index()
            
            # Create the bar chart
            plt.figure(figsize=(14, 8))
            
            # Set up bar positions
            provinces = grouped[province_col].tolist()
            x = np.arange(len(provinces))
            width = 0.8 / len(data_cols)
            
            # Plot bars
            colors = ['#1f77b4', '#ff7f0e', '#2ca02c']  # Blue, orange, green
            for i, col in enumerate(data_cols):
                offset = (i - len(data_cols)/2 + 0.5) * width
                plt.bar(x + offset, grouped[col], width, label=col, color=colors[i % len(colors)])
            
            # Add labels and formatting
            plt.xlabel('Province')
            plt.ylabel('Number of Applications')
            plt.title('Applications by Province')
            plt.xticks(x, provinces, rotation=45)
            plt.legend()
            plt.grid(True, alpha=0.3)
            plt.tight_layout()
            
            # Save the figure
            plt.savefig('applications_by_province.png', dpi=300, bbox_inches='tight')
            plt.close()
            
            print("Province bar chart created successfully.")
        
        except Exception as e:
            print(f"Error creating province bar chart: {str(e)}")
    
    except Exception as e:
        print(f"Error in province bar chart creation: {str(e)}")

def main():
    """
    Main function to execute the analysis
    """
    print("Starting ultra-simple analysis...")
    
    # Load and process the data files
    app_df = load_and_process_application_data()
    mailout_df = load_and_process_mailout_data()
    
    # Create the bar chart (which worked previously)
    if app_df is not None:
        create_province_bar_chart(app_df)
        
        # Save processed data
        app_df.to_csv('processed_applications_data.csv', index=False)
        print("\nProcessed data saved to 'processed_applications_data.csv'")
    
    print("\nAnalysis completed.")

if __name__ == "__main__":
    main()