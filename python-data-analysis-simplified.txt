import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import warnings

# Suppress warnings for cleaner output
warnings.filterwarnings('ignore')

def load_excel_file(file_path, sheet_name=0):
    """
    Load an Excel file with basic error handling
    """
    try:
        print(f"Loading {file_path}...")
        df = pd.read_excel(file_path, sheet_name=sheet_name)
        print(f"Successfully loaded: {file_path}, shape: {df.shape}")
        print(f"Columns: {df.columns.tolist()}")
        print(f"First few rows:")
        print(df.head(2))
        return df
    except Exception as e:
        print(f"Error loading {file_path}: {str(e)}")
        return None

def clean_applications_data(df):
    """
    Clean applications data with minimal processing
    """
    if df is None:
        return None
    
    print("\nCleaning applications data...")
    
    # Make a copy to avoid modifying the original
    clean_df = df.copy()
    
    # Fix column names - assume standard ordering but check actual names
    # This is just a fallback in case column names are not ideal
    col_names = clean_df.columns.tolist()
    expected_cols = ['Date', 'Province', 'New Applications Received', 'New Applications Completed', 
                     'New Applications Eligible', 'Renewals Received', 'Renewals Completed', 
                     'Renewals Eligible', 'Total Received', 'Total Completed', 'Total Eligible']
    
    # If there's a column name mismatch, try to fix based on position
    if set(expected_cols) - set(col_names):
        # If first row looks like header, use it
        if isinstance(clean_df.iloc[0, 0], str) and 'date' in clean_df.iloc[0, 0].lower():
            print("Using first row as header")
            new_header = clean_df.iloc[0]
            clean_df = clean_df[1:]
            clean_df.columns = new_header
        # Otherwise, try renaming based on position if the column count matches
        elif len(col_names) == len(expected_cols):
            print("Renaming columns based on expected order")
            clean_df.columns = expected_cols
    
    # Convert date column to datetime
    date_col = next((col for col in clean_df.columns if 'date' in col.lower()), None)
    if date_col:
        clean_df[date_col] = pd.to_datetime(clean_df[date_col], errors='coerce')
        # Rename to standardized 'Date' if needed
        if date_col != 'Date':
            clean_df = clean_df.rename(columns={date_col: 'Date'})
    
    # Find province column
    prov_col = next((col for col in clean_df.columns 
                     if 'prov' in col.lower() or 'state' in col.lower() or 'region' in col.lower()), None)
    if prov_col and prov_col != 'Province':
        clean_df = clean_df.rename(columns={prov_col: 'Province'})
    
    # Filter out rows where Province is 'Total'
    if 'Province' in clean_df.columns:
        total_mask = clean_df['Province'].astype(str).str.lower() == 'total'
        clean_df = clean_df[~total_mask]
        print(f"Removed {sum(total_mask)} rows where Province is 'Total'")
    
    # Drop rows with missing dates
    if 'Date' in clean_df.columns:
        original_count = len(clean_df)
        clean_df = clean_df.dropna(subset=['Date'])
        print(f"Dropped {original_count - len(clean_df)} rows with missing dates")
    
    # Convert all numeric columns to numeric, ignoring errors
    numeric_cols = [col for col in clean_df.columns 
                   if col not in ['Date', 'Province']]
    for col in numeric_cols:
        clean_df[col] = pd.to_numeric(clean_df[col], errors='coerce').fillna(0)
    
    print(f"Cleaned data shape: {clean_df.shape}")
    
    return clean_df

def clean_mailout_data(df):
    """
    Clean mailout data with minimal processing
    """
    if df is None:
        return None
    
    print("\nCleaning mailout data...")
    
    # Make a copy to avoid modifying the original
    clean_df = df.copy()
    
    # Ensure we have proper column names
    col_names = clean_df.columns.tolist()
    
    # If we only have two columns, assume they're Date and Mailout
    if len(col_names) == 2:
        clean_df.columns = ['Date', 'Mailout']
    # Otherwise, try to identify the right columns
    else:
        # Find date column
        date_col = next((col for col in clean_df.columns if 'date' in col.lower()), None)
        # Find mailout column - look for keywords
        mailout_col = next((col for col in clean_df.columns 
                           if any(word in col.lower() for word in ['mail', 'letter', 'sent', 'schedule'])), 
                          None)
        
        # If we found them, rename columns
        if date_col and mailout_col:
            clean_df = clean_df[[date_col, mailout_col]]
            clean_df.columns = ['Date', 'Mailout']
    
    # Convert date column to datetime
    clean_df['Date'] = pd.to_datetime(clean_df['Date'], errors='coerce')
    
    # Drop rows with missing dates
    original_count = len(clean_df)
    clean_df = clean_df.dropna(subset=['Date'])
    print(f"Dropped {original_count - len(clean_df)} rows with missing dates")
    
    # Convert Mailout to numeric
    clean_df['Mailout'] = pd.to_numeric(clean_df['Mailout'], errors='coerce').fillna(0)
    
    # Ensure unique dates
    clean_df = clean_df.drop_duplicates(subset=['Date'])
    
    print(f"Cleaned mailout data shape: {clean_df.shape}")
    
    return clean_df

def create_province_bar_chart(df):
    """
    Create a bar chart showing renewals by province
    """
    if df is None or 'Province' not in df.columns:
        print("Cannot create province bar chart - missing required data")
        return
    
    print("\nCreating renewals by province bar chart...")
    
    # Group by province and sum the renewals columns
    renewals_columns = [col for col in df.columns 
                       if 'renewal' in col.lower() and any(word in col.lower() 
                                                          for word in ['received', 'completed', 'eligible'])]
    
    # If we don't have the right columns, use what we have
    if not renewals_columns:
        renewals_columns = [col for col in df.columns 
                           if col not in ['Date', 'Province', 'Mailout'] and col.lower() != 'date']
    
    # Group by province and sum renewal columns
    province_data = df.groupby('Province')[renewals_columns].sum().reset_index()
    
    # Create the bar chart
    plt.figure(figsize=(14, 8))
    
    # Calculate bar positions
    x = np.arange(len(province_data))
    width = 0.8 / len(renewals_columns)
    
    # Set colors
    colors = ['#1f77b4', '#ff7f0e', '#2ca02c']  # blue, orange, green
    
    # Plot bars
    for i, col in enumerate(renewals_columns):
        offset = (i - len(renewals_columns)/2 + 0.5) * width
        plt.bar(x + offset, province_data[col], width, label=col, color=colors[i % len(colors)])
    
    # Add labels and title
    plt.xlabel('Province')
    plt.ylabel('Number of Applications')
    plt.title('Renewals Applications by Province')
    plt.xticks(x, province_data['Province'], rotation=45)
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    
    # Save the chart
    plt.savefig('renewals_by_province.png', dpi=300, bbox_inches='tight')
    plt.close()
    
    print("Bar chart created: renewals_by_province.png")

def create_time_series_charts(app_df, mailout_df):
    """
    Create time series charts
    """
    if app_df is None:
        print("Cannot create time series charts - missing application data")
        return
    
    print("\nCreating time series charts...")
    
    # Ensure we have a Date column
    if 'Date' not in app_df.columns:
        print("Cannot create time series charts - missing Date column")
        return
    
    # Format function for date axis
    def format_date_axis(ax):
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
        ax.xaxis.set_major_locator(mdates.MonthLocator())
        plt.xticks(rotation=45)
        plt.tight_layout()
    
    # If we have province data, create province-specific charts
    if 'Province' in app_df.columns:
        for province in app_df['Province'].unique():
            prov_data = app_df[app_df['Province'] == province].sort_values('Date')
            
            # Skip if not enough data
            if len(prov_data) < 2:
                continue
            
            # Find renewal columns
            renewal_cols = [col for col in prov_data.columns 
                           if 'renewal' in col.lower() and any(word in col.lower() 
                                                              for word in ['received', 'completed', 'eligible'])]
            
            # Skip if no renewal columns
            if not renewal_cols:
                continue
            
            plt.figure(figsize=(14, 8))
            for col in renewal_cols:
                plt.plot(prov_data['Date'], prov_data[col], label=col, linewidth=2)
            
            plt.title(f'Renewals Applications for {province}')
            plt.xlabel('Date')
            plt.ylabel('Number of Applications')
            plt.legend()
            plt.grid(True, alpha=0.3)
            
            ax = plt.gca()
            format_date_axis(ax)
            
            plt.savefig(f'renewals_by_date_{province}.png', dpi=300, bbox_inches='tight')
            plt.close()
            
            print(f"Created time series chart for {province}")
    
    # Create total applications charts
    # First, prepare the data
    if 'Province' in app_df.columns:
        # Group by date to get daily totals
        total_cols = [col for col in app_df.columns 
                     if 'total' in col.lower() and any(word in col.lower() 
                                                     for word in ['received', 'completed', 'eligible'])]
        
        if total_cols:
            daily_totals = app_df.groupby('Date')[total_cols].sum().reset_index()
            
            # Create charts for each total column
            for col in total_cols:
                plt.figure(figsize=(14, 8))
                plt.plot(daily_totals['Date'], daily_totals[col], linewidth=2)
                
                plt.title(f'{col} Over Time')
                plt.xlabel('Date')
                plt.ylabel('Number of Applications')
                plt.grid(True, alpha=0.3)
                
                ax = plt.gca()
                format_date_axis(ax)
                
                filename = col.lower().replace(' ', '_') + '.png'
                plt.savefig(filename, dpi=300, bbox_inches='tight')
                plt.close()
                
                print(f"Created time series chart for {col}")
    
    # Create mailout vs received chart if we have mailout data
    if mailout_df is not None and 'Date' in app_df.columns and 'Total Received' in app_df.columns:
        # Prepare data
        if 'Province' in app_df.columns:
            app_daily = app_df.groupby('Date')['Total Received'].sum().reset_index()
        else:
            app_daily = app_df[['Date', 'Total Received']].copy()
        
        # Merge with mailout data
        merged = pd.merge(app_daily, mailout_df, on='Date', how='outer').sort_values('Date')
        merged = merged.fillna(0)
        
        # Create dual-axis chart
        fig, ax1 = plt.subplots(figsize=(14, 8))
        
        color1 = 'tab:blue'
        ax1.set_xlabel('Date')
        ax1.set_ylabel('Total Applications Received', color=color1)
        ax1.plot(merged['Date'], merged['Total Received'], color=color1, linewidth=2)
        ax1.tick_params(axis='y', labelcolor=color1)
        
        ax2 = ax1.twinx()
        color2 = 'tab:orange'
        ax2.set_ylabel('Mailout Letters Sent', color=color2)
        ax2.plot(merged['Date'], merged['Mailout'], color=color2, linestyle='--', linewidth=2)
        ax2.tick_params(axis='y', labelcolor=color2)
        
        plt.title('Comparison of Mailout Letters Sent and Total Applications Received')
        
        # Format date axis
        ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
        ax1.xaxis.set_major_locator(mdates.MonthLocator())
        fig.autofmt_xdate()
        
        plt.tight_layout()
        plt.savefig('received_vs_mailout.png', dpi=300, bbox_inches='tight')
        plt.close()
        
        print("Created mailout vs received chart")
        
        # Create cumulative takeup chart
        merged['Cumulative Received'] = merged['Total Received'].cumsum()
        merged['Cumulative Mailout'] = merged['Mailout'].cumsum()
        merged['Cumulative Takeup'] = (merged['Cumulative Received'] / 
                                     merged['Cumulative Mailout'].replace(0, np.nan)) * 100
        merged['Cumulative Takeup'] = merged['Cumulative Takeup'].fillna(0)
        
        plt.figure(figsize=(14, 8))
        plt.plot(merged['Date'], merged['Cumulative Takeup'], linewidth=2)
        
        plt.title('Cumulative Takeup Percentage Over Time')
        plt.xlabel('Date')
        plt.ylabel('Percentage (%)')
        plt.grid(True, alpha=0.3)
        
        ax = plt.gca()
        format_date_axis(ax)
        
        plt.savefig('cumulative_takeup.png', dpi=300, bbox_inches='tight')
        plt.close()
        
        print("Created cumulative takeup chart")

def main():
    """
    Main function to run the analysis
    """
    print("Starting simplified applications and renewals analysis...")
    
    # 1. Load the data files with minimal processing
    app_df = load_excel_file('Applications_Renewals_by_Date_20250414.xlsx')
    mailout_df = load_excel_file('Mailout_Schedule.xlsx')
    
    # 2. Clean the data with basic processing
    clean_app_df = clean_applications_data(app_df)
    clean_mailout_df = clean_mailout_data(mailout_df)
    
    # 3. Create visualizations
    # Province bar chart (the one that worked before)
    create_province_bar_chart(clean_app_df)
    
    # Time series charts
    create_time_series_charts(clean_app_df, clean_mailout_df)
    
    # 4. Save processed data
    if clean_app_df is not None:
        clean_app_df.to_csv('processed_applications_data.csv', index=False)
        print("\nProcessed applications data saved to 'processed_applications_data.csv'")
    
    print("\nAnalysis completed!")

if __name__ == "__main__":
    main()