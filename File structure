import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import os
import openpyxl
from openpyxl.utils import get_column_letter
import re

def extract_call_volumes(file_path, target_date=None):
    """
    Extract call volume data from the call volume file.
    Focuses on daily data columns starting from column H (2025-04-01).
    
    Args:
        file_path: Path to the call volume Excel file
        target_date: Optional specific date to extract data for (format: 'YYYY-MM-DD')
    
    Returns:
        Dictionary with dates as keys and tuples of (call_volumes_18_64, sum_calls_except_18_64) as values
    """
    print(f"Reading call volume file: {file_path}")
    
    try:
        # Read the Excel file
        workbook = openpyxl.load_workbook(file_path, data_only=True)
        sheet = workbook["Rpt-Vol (daily-quotidien)"]
        
        # Find date columns starting from column H (index 8)
        date_columns = {}  # Dictionary to store {column_index: date_string}
        
        # Search for date headers in rows 1-10, starting from column H
        for row in range(1, 10):
            for col in range(8, sheet.max_column + 1):  # Start from column H (index 8)
                cell_value = sheet.cell(row=row, column=col).value
                if cell_value:
                    # Check for date columns (format: YYYY-MM-DD or similar)
                    if isinstance(cell_value, datetime):
                        date_str = cell_value.strftime('%Y-%m-%d')
                        date_columns[col] = date_str
                        print(f"Found date column at position {col} ({get_column_letter(col)}): {date_str}")
                    elif isinstance(cell_value, str):
                        # Look for date patterns in strings
                        date_pattern = re.search(r'(20\d\d[-/]\d\d[-/]\d\d)', cell_value)
                        if date_pattern:
                            date_str = date_pattern.group(1).replace('/', '-')
                            date_columns[col] = date_str
                            print(f"Found date column at position {col} ({get_column_letter(col)}): {date_str}")
        
        # Filter date columns if a target date is specified
        if target_date and date_columns:
            filtered_date_columns = {k: v for k, v in date_columns.items() if v == target_date}
            if filtered_date_columns:
                date_columns = filtered_date_columns
                print(f"Filtered to target date: {target_date}")
            else:
                print(f"WARNING: Specified date {target_date} not found in data")
        
        # If no date columns found, this is an error
        if not date_columns:
            print("ERROR: No date columns found starting from column H")
            return None
        
        # Process each date column
        results = {}
        for col, date_str in date_columns.items():
            print(f"\nProcessing data for date: {date_str} (column {get_column_letter(col)})")
            
            # Define the specific rows containing the 18-64 age groups (rows 53, 54, 55)
            age_group_18_64_rows = [53, 54, 55]
            
            # Define rows to exclude (crossed out rows 49, 50, 51, 52)
            excluded_rows = [49, 50, 51, 52]
            
            # Define the other age groups (rows 42-48, REMOVED row 56 "Not Applicable / Unknown")
            other_age_group_rows = list(range(42, 49))  # Only includes rows 42-48
            
            # Initialize counters for this date
            call_volumes_18_64 = 0
            sum_calls_except_18_64 = 0
            age_groups_18_64 = []
            other_age_groups = []
            
            # Extract values from the 18-64 age group rows
            for row in age_group_18_64_rows:
                cell_value = sheet.cell(row=row, column=col).value
                label = sheet.cell(row=row, column=3).value  # Column C with description
                
                if cell_value is not None:
                    # Convert to float if it's a string with commas
                    if isinstance(cell_value, str):
                        try:
                            cell_value = float(cell_value.replace(',', ''))
                        except ValueError:
                            print(f"  Warning: Could not convert value '{cell_value}' to number at row {row}, col {col}")
                            cell_value = 0
                    
                    # Handle cases where cell_value might be empty or None
                    if isinstance(cell_value, (int, float)):
                        call_volumes_18_64 += cell_value
                        age_groups_18_64.append((label, cell_value))
            
            # Extract values from the other age group rows
            for row in other_age_group_rows:
                cell_value = sheet.cell(row=row, column=col).value
                label = sheet.cell(row=row, column=3).value  # Column C with description
                
                if cell_value is not None:
                    # Convert to float if it's a string with commas
                    if isinstance(cell_value, str):
                        try:
                            cell_value = float(cell_value.replace(',', ''))
                        except ValueError:
                            print(f"  Warning: Could not convert value '{cell_value}' to number at row {row}, col {col}")
                            cell_value = 0
                    
                    # Handle cases where cell_value might be empty or None
                    if isinstance(cell_value, (int, float)):
                        sum_calls_except_18_64 += cell_value
                        other_age_groups.append((label, cell_value))
            
            # Print the found age groups and their values for this date
            print(f"  Age groups for 18-64:")
            for label, value in age_groups_18_64:
                print(f"    - {label}: {value}")
            print(f"  Total call volumes for 18-64: {call_volumes_18_64}")
            
            print(f"  Age groups except 18-64:")
            for label, value in other_age_groups:
                print(f"    - {label}: {value}")
            print(f"  Total call volumes except 18-64: {sum_calls_except_18_64}")
            
            # Store results for this date
            results[date_str] = (call_volumes_18_64, sum_calls_except_18_64)
        
        return results
        
    except Exception as e:
        print(f"Error extracting call volumes: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

def extract_application_volumes(file_path, target_date=None):
    """
    Extract application volume data for RENEWALS from the applications volume file.
    
    Args:
        file_path: Path to the applications volume Excel file
        target_date: Optional specific date to extract data for (format: 'YYYY-MM-DD')
    
    Returns:
        Dictionary with dates as keys and renewals applications values
    """
    print(f"Reading applications volume file for RENEWALS: {file_path}")
    
    try:
        # Read the Excel file - specifically setting header=2 (which means row 3 in Excel)
        df = pd.read_excel(file_path, sheet_name="Sheet1", header=2)
        
        # Debug: Display first few rows and columns
        print("First few rows of applications file (with header at row 3):")
        print(df.head(2))
        print("Columns:", df.columns.tolist())
        
        # From the image, we can see the exact column structure:
        # - Column A: "Date"
        # - Column C: "Received"
        # - Column F: "Type"
        
        # Try to identify these columns by name first
        date_col = None
        receive_col = None
        type_col = None
        
        for col in df.columns:
            col_str = str(col).lower()
            if col_str == "date":
                date_col = col
            elif col_str == "received":
                receive_col = col
            elif col_str == "type":
                type_col = col
        
        # If not found by exact name, try positional matching based on the image
        if date_col is None and len(df.columns) > 0:
            date_col = df.columns[0]  # Column A
            print(f"Using positional fallback for date column: {date_col}")
        
        if receive_col is None and len(df.columns) > 2:
            receive_col = df.columns[2]  # Column C
            print(f"Using positional fallback for receive column: {receive_col}")
        
        if type_col is None and len(df.columns) > 5:
            type_col = df.columns[5]  # Column F
            print(f"Using positional fallback for type column: {type_col}")
        
        print(f"Using columns: '{date_col}' for Date, '{receive_col}' for Receive, '{type_col}' for Type")
        
        # Make sure the date column is in datetime format
        df[date_col] = pd.to_datetime(df[date_col], errors='coerce')
        
        # Filter to target date if specified
        if target_date:
            target_dt = pd.to_datetime(target_date)
            df = df[df[date_col].dt.date == target_dt.date()]
            if df.empty:
                print(f"WARNING: No data found for target date {target_date}")
                return None
        
        # Process data by date - ONLY FOR RENEWALS
        results = {}
        # Group by date
        for date, group in df.groupby(df[date_col].dt.date):
            date_str = date.strftime('%Y-%m-%d')
            
            # Sum applications for Renewals
            renewals_df = group[group[type_col] == "Renewals"]
            applications_renewals = renewals_df[receive_col].sum()
            
            print(f"Applications for {date_str}:")
            print(f"  - Renewals ({len(renewals_df)} rows): {applications_renewals}")
            
            results[date_str] = applications_renewals
        
        return results
        
    except Exception as e:
        print(f"Error extracting renewals application volumes: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

def extract_new_applications_volumes(file_path, target_date=None):
    """
    Extract application volume data for NEW APPLICATIONS from the third dataset.
    
    Args:
        file_path: Path to the new applications volume Excel file
        target_date: Optional specific date to extract data for (format: 'YYYY-MM-DD')
    
    Returns:
        Dictionary with dates as keys and new applications values
    """
    print(f"Reading dedicated NEW APPLICATIONS volume file: {file_path}")
    
    try:
        # Read the Excel file - specifically setting header=2 (which means row 3 in Excel)
        df = pd.read_excel(file_path, sheet_name="Sheet1", header=2)
        
        # Debug: Display first few rows and columns
        print("First few rows of new applications file (with header at row 3):")
        print(df.head(2))
        print("Columns:", df.columns.tolist())
        
        # From the image, we can see the exact column structure:
        # - Column A: "Date"
        # - Column C: "Received"
        # - Column F: "Type"
        
        # Try to identify these columns by name first
        date_col = None
        receive_col = None
        type_col = None
        
        for col in df.columns:
            col_str = str(col).lower()
            if col_str == "date":
                date_col = col
            elif col_str == "received":
                receive_col = col
            elif col_str == "type":
                type_col = col
        
        # If not found by exact name, try positional matching based on the image
        if date_col is None and len(df.columns) > 0:
            date_col = df.columns[0]  # Column A
            print(f"Using positional fallback for date column: {date_col}")
        
        if receive_col is None and len(df.columns) > 2:
            receive_col = df.columns[2]  # Column C
            print(f"Using positional fallback for receive column: {receive_col}")
        
        if type_col is None and len(df.columns) > 5:
            type_col = df.columns[5]  # Column F
            print(f"Using positional fallback for type column: {type_col}")
        
        print(f"Using columns: '{date_col}' for Date, '{receive_col}' for Receive, '{type_col}' for Type")
        
        # Make sure the date column is in datetime format
        df[date_col] = pd.to_datetime(df[date_col], errors='coerce')
        
        # Filter to target date if specified
        if target_date:
            target_dt = pd.to_datetime(target_date)
            df = df[df[date_col].dt.date == target_dt.date()]
            if df.empty:
                print(f"WARNING: No data found for target date {target_date}")
                return None
        
        # Process data by date - ONLY FOR NEW APPLICATIONS
        results = {}
        # Group by date
        for date, group in df.groupby(df[date_col].dt.date):
            date_str = date.strftime('%Y-%m-%d')
            
            # Sum applications for New Applications
            new_apps_df = group[group[type_col] == "New Applications"]
            applications_new = new_apps_df[receive_col].sum()
            
            print(f"New Applications for {date_str}:")
            print(f"  - New Applications ({len(new_apps_df)} rows): {applications_new}")
            
            results[date_str] = applications_new
        
        return results
        
    except Exception as e:
        print(f"Error extracting new applications volumes: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

def calculate_calling_rates(call_data, renewals_data, new_apps_data):
    """
    Calculate the calling rates based on the extracted data.
    
    Args:
        call_data: Dictionary with dates as keys and (call_volumes_18_64, sum_calls_except_18_64) as values
        renewals_data: Dictionary with dates as keys and applications_renewals as values
        new_apps_data: Dictionary with dates as keys and applications_new as values
    
    Returns:
        Dictionary with dates as keys and (calling_rate_new, calling_rate_renewals) as values
    """
    try:
        results = {}
        
        # Find common dates across all three datasets
        call_dates = set(call_data.keys())
        renewals_dates = set(renewals_data.keys())
        new_apps_dates = set(new_apps_data.keys())
        
        common_dates = call_dates.intersection(renewals_dates).intersection(new_apps_dates)
        
        if not common_dates:
            print("\nWARNING: No common dates found across all three datasets")
            print("Call data dates:", sorted(list(call_dates)))
            print("Renewals data dates:", sorted(list(renewals_dates)))
            print("New Applications data dates:", sorted(list(new_apps_dates)))
            return None
        
        for date in sorted(common_dates):
            call_volumes_18_64, sum_calls_except_18_64 = call_data[date]
            applications_renewals = renewals_data[date]
            applications_new = new_apps_data[date]
            
            print(f"\nCalculating rates for {date}:")
            print(f"  Call volumes 18-64: {call_volumes_18_64}")
            print(f"  Sum calls except 18-64: {sum_calls_except_18_64}")
            print(f"  Applications new: {applications_new}")
            print(f"  Applications renewals: {applications_renewals}")
            
            # Calculate calling rate for new applications
            calling_rate_new = 0
            if applications_new > 0:
                calling_rate_new = call_volumes_18_64 / applications_new
            else:
                print(f"  Warning: Zero applications for new (18-64) for {date}")
            
            # OLD FORMULA: Calculate calling rate for renewals
            calling_rate_renewals = 0
            if applications_renewals > 0:
                # Using sum_calls_except_18_64 for the original formula
                calling_rate_renewals = sum_calls_except_18_64 / applications_renewals
            else:
                print(f"  Warning: Zero applications for renewals for {date}")
            
            print(f"  Calculated calling rates for {date}:")
            print(f"    - New Applications: {calling_rate_new:.4f}")
            print(f"    - Renewals (ORIGINAL FORMULA): {calling_rate_renewals:.4f}")
            
            results[date] = (calling_rate_new, calling_rate_renewals)
        
        return results
        
    except Exception as e:
        print(f"Error calculating calling rates: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

def update_output_file(output_path, rate_data):
    """
    Update the output Excel file with the new calling rates.
    
    Args:
        output_path: Path to the output Excel file
        rate_data: Dictionary with dates as keys and (calling_rate_new, calling_rate_renewals) as values
    
    Returns:
        Boolean indicating success or failure
    """
    try:
        # Initialize DataFrame with existing data or create new one
        if os.path.exists(output_path):
            print(f"Output file exists, reading: {output_path}")
            df = pd.read_excel(output_path)
            
            # Convert Date column to datetime if it isn't already
            if 'Date' in df.columns:
                df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
                
            # Check if we have the right columns
            if 'Calling Rate New Applications' not in df.columns:
                df['Calling Rate New Applications'] = 0
            if 'Calling Rate Renewals' not in df.columns:
                df['Calling Rate Renewals'] = 0
        else:
            print(f"Output file does not exist, creating new file: {output_path}")
            df = pd.DataFrame(columns=["Date", "Calling Rate New Applications", "Calling Rate Renewals"])
        
        # Initialize data rows to add
        new_rows = []
        updated_count = 0
        
        # Process each date's data
        for date_str, (calling_rate_new, calling_rate_renewals) in sorted(rate_data.items()):
            date = pd.to_datetime(date_str)
            
            # Check if this date already exists in the DataFrame
            date_exists = False
            
            # Use proper pandas datetime comparison
            if not df.empty and 'Date' in df.columns:
                mask = df['Date'].dt.strftime('%Y-%m-%d') == date.strftime('%Y-%m-%d')
                matching_rows = df[mask]
                
                if not matching_rows.empty:
                    # Update existing row
                    df.loc[mask, 'Calling Rate New Applications'] = calling_rate_new
                    df.loc[mask, 'Calling Rate Renewals'] = calling_rate_renewals
                    updated_count += 1
                    date_exists = True
                    print(f"Updated existing data for {date_str}")
            
            # If date doesn't exist, add a new row
            if not date_exists:
                new_rows.append({
                    "Date": date,
                    "Calling Rate New Applications": calling_rate_new,
                    "Calling Rate Renewals": calling_rate_renewals
                })
                print(f"Adding new data for {date_str}")
        
        # Add any new rows
        if new_rows:
            new_df = pd.DataFrame(new_rows)
            df = pd.concat([df, new_df], ignore_index=True)
        
        # Sort by date
        df = df.sort_values('Date')
        
        # Format the date column to ensure it's just the date (no time)
        df['Date'] = pd.to_datetime(df['Date']).dt.date
        
        # Save the DataFrame to Excel
        df.to_excel(output_path, index=False)
        
        print(f"Output file updated successfully: {output_path}")
        print(f"  - Updated {updated_count} existing entries")
        print(f"  - Added {len(new_rows)} new entries")
        print(f"  - Total entries: {len(df)}")
        
        return True
        
    except Exception as e:
        print(f"Error updating output file: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

def main():
    """Main function to run the daily calling rate calculation."""
    # File paths - UPDATE THESE WITH YOUR ACTUAL PATHS
    call_volume_path = "path/to/call_volume_file.xlsx"
    renewals_app_path = "path/to/renewals_applications_file.xlsx"  # Renamed to clarify purpose
    new_app_path = "path/to/new_applications_file.xlsx"  # New third dataset
    output_path = "path/to/output_file.xlsx"
    
    print(f"Starting calling rate calculation...")
    
    # Ask user whether to process historical data or just yesterday's data
    process_type = input("Do you want to process (1) historical data from Jan 2025 onwards or (2) just yesterday's data? Enter 1 or 2: ")
    
    # Extract call volume data - this comes from the daily columns (H onwards)
    if process_type == "1":
        # Process all historical data (all date columns)
        call_data = extract_call_volumes(call_volume_path)
    else:
        # Process just yesterday's data
        yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
        call_data = extract_call_volumes(call_volume_path, yesterday)
    
    if not call_data:
        print("ERROR: Failed to extract call volume data.")
        return
    
    # Extract RENEWALS application volumes
    if process_type == "1":
        # Process all historical data
        renewals_data = extract_application_volumes(renewals_app_path)
    else:
        # Process just yesterday's data
        yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
        renewals_data = extract_application_volumes(renewals_app_path, yesterday)
    
    if not renewals_data:
        print("ERROR: Failed to extract renewals application data.")
        return
    
    # Extract NEW application volumes from the third dataset
    if process_type == "1":
        # Process all historical data
        new_apps_data = extract_new_applications_volumes(new_app_path)
    else:
        # Process just yesterday's data
        yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
        new_apps_data = extract_new_applications_volumes(new_app_path, yesterday)
    
    if not new_apps_data:
        print("ERROR: Failed to extract new applications data.")
        return
    
    # Calculate rates using all three datasets
    rate_data = calculate_calling_rates(call_data, renewals_data, new_apps_data)
    if not rate_data:
        print("ERROR: Failed to calculate calling rates.")
        return
    
    # Update output file
    success = update_output_file(output_path, rate_data)
    
    if success:
        print("\n✅ SUCCESS: Calling rates have been calculated and saved.")
        print("    - New Applications Rate: Call Volumes for 18-64 age groups / New Applications for 18-64")
        print("    - Renewals Rate (ORIGINAL FORMULA): Sum of calls for all age groups except 18-64")
        print("                                        (excluding 'Not Applicable / Unknown')")
        print("                                        divided by Applications for Renewals")
        print("\nPlease verify the output file to ensure the rates look correct.")
    else:
        print("\n❌ ERROR: Failed to complete the calculation.")

if __name__ == "__main__":
    main()
