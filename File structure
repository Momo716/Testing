import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import os
import openpyxl
from openpyxl.utils import get_column_letter
import re

def extract_call_volumes(file_path, target_date=None):
    """
    Extract call volume data from the call volume file.
    Focuses on daily data columns starting from column H (2025-04-01).
    
    Args:
        file_path: Path to the call volume Excel file
        target_date: Optional specific date to extract data for (format: 'YYYY-MM-DD')
    
    Returns:
        Dictionary with dates as keys and tuples of (call_volumes_18_64, sum_calls_except_18_64) as values
    """
    print(f"Reading call volume file: {file_path}")
    
    try:
        # Read the Excel file
        workbook = openpyxl.load_workbook(file_path, data_only=True)
        sheet = workbook["Rpt-Vol (daily-quotidien)"]
        
        # Find date columns starting from column H (index 8)
        date_columns = {}  # Dictionary to store {column_index: date_string}
        
        # Search for date headers in rows 1-10, starting from column H
        for row in range(1, 10):
            for col in range(8, sheet.max_column + 1):  # Start from column H (index 8)
                cell_value = sheet.cell(row=row, column=col).value
                if cell_value:
                    # Check for date columns (format: YYYY-MM-DD or similar)
                    if isinstance(cell_value, datetime):
                        date_str = cell_value.strftime('%Y-%m-%d')
                        date_columns[col] = date_str
                        print(f"Found date column at position {col} ({get_column_letter(col)}): {date_str}")
                    elif isinstance(cell_value, str):
                        # Look for date patterns in strings
                        date_pattern = re.search(r'(20\d\d[-/]\d\d[-/]\d\d)', cell_value)
                        if date_pattern:
                            date_str = date_pattern.group(1).replace('/', '-')
                            date_columns[col] = date_str
                            print(f"Found date column at position {col} ({get_column_letter(col)}): {date_str}")
        
        # Filter date columns if a target date is specified
        if target_date and date_columns:
            filtered_date_columns = {k: v for k, v in date_columns.items() if v == target_date}
            if filtered_date_columns:
                date_columns = filtered_date_columns
                print(f"Filtered to target date: {target_date}")
            else:
                print(f"WARNING: Specified date {target_date} not found in data")
        
        # If no date columns found, this is an error
        if not date_columns:
            print("ERROR: No date columns found starting from column H")
            return None
        
        # Process each date column
        results = {}
        for col, date_str in date_columns.items():
            print(f"\nProcessing data for date: {date_str} (column {get_column_letter(col)})")
            
            # Define the specific rows containing the 18-64 age groups (rows 53, 54, 55)
            age_group_18_64_rows = [53, 54, 55]
            
            # Define rows to exclude (crossed out rows 49, 50, 51, 52)
            excluded_rows = [49, 50, 51, 52]
            
            # Define the other age groups (rows 42-48 plus row 56)
            other_age_group_rows = list(range(42, 49)) + [56]
            
            # Initialize counters for this date
            call_volumes_18_64 = 0
            sum_calls_except_18_64 = 0
            age_groups_18_64 = []
            other_age_groups = []
            
            # Extract values from the 18-64 age group rows
            for row in age_group_18_64_rows:
                cell_value = sheet.cell(row=row, column=col).value
                label = sheet.cell(row=row, column=3).value  # Column C with description
                
                if cell_value is not None:
                    # Convert to float if it's a string with commas
                    if isinstance(cell_value, str):
                        try:
                            cell_value = float(cell_value.replace(',', ''))
                        except ValueError:
                            print(f"  Warning: Could not convert value '{cell_value}' to number at row {row}, col {col}")
                            cell_value = 0
                    
                    # Handle cases where cell_value might be empty or None
                    if isinstance(cell_value, (int, float)):
                        call_volumes_18_64 += cell_value
                        age_groups_18_64.append((label, cell_value))
            
            # Extract values from the other age group rows
            for row in other_age_group_rows:
                cell_value = sheet.cell(row=row, column=col).value
                label = sheet.cell(row=row, column=3).value  # Column C with description
                
                if cell_value is not None:
                    # Convert to float if it's a string with commas
                    if isinstance(cell_value, str):
                        try:
                            cell_value = float(cell_value.replace(',', ''))
                        except ValueError:
                            print(f"  Warning: Could not convert value '{cell_value}' to number at row {row}, col {col}")
                            cell_value = 0
                    
                    # Handle cases where cell_value might be empty or None
                    if isinstance(cell_value, (int, float)):
                        sum_calls_except_18_64 += cell_value
                        other_age_groups.append((label, cell_value))
            
            # Print the found age groups and their values for this date
            print(f"  Age groups for 18-64:")
            for label, value in age_groups_18_64:
                print(f"    - {label}: {value}")
            print(f"  Total call volumes for 18-64: {call_volumes_18_64}")
            
            print(f"  Age groups except 18-64:")
            for label, value in other_age_groups:
                print(f"    - {label}: {value}")
            print(f"  Total call volumes except 18-64: {sum_calls_except_18_64}")
            
            # Store results for this date
            results[date_str] = (call_volumes_18_64, sum_calls_except_18_64)
        
        return results
        
    except Exception as e:
        print(f"Error extracting call volumes: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

def extract_application_volumes(file_path, target_date=None):
    """
    Extract application volume data from the applications volume file.
    
    Args:
        file_path: Path to the applications volume Excel file
        target_date: Optional specific date to extract data for (format: 'YYYY-MM-DD')
    
    Returns:
        Dictionary with dates as keys and tuples of (applications_18_64_new, applications_18_64_renewals) as values
    """
    print(f"Reading applications volume file: {file_path}")
    
    try:
        # Read the Excel file
        df = pd.read_excel(file_path, sheet_name="Sheet1")
        
        # Debug: Display first few rows of the DataFrame
        print("First few rows of applications file:")
        print(df.head(2))
        print("Columns:", df.columns.tolist())
        
        # Look for receive and type columns - be more flexible in detection
        receive_col = None
        type_col = None
        
        # Try to identify columns by column header text
        for col in df.columns:
            col_str = str(col).lower()
            # Check for receive column
            if "receive" in col_str or "recu" in col_str:
                receive_col = col
                print(f"Found receive column: {col}")
            # Check for type column
            elif "type" in col_str or "type" == col_str:
                type_col = col
                print(f"Found type column: {col}")
        
        # If still not found, use positional fallbacks (from image 4)
        if receive_col is None and len(df.columns) > 1:
            receive_col = df.columns[1]  # Column B
            print(f"Using positional fallback for receive column: {receive_col}")
        
        if type_col is None and len(df.columns) > 4:
            type_col = df.columns[4]  # Column E
            print(f"Using positional fallback for type column: {type_col}")
        
        print(f"Using columns: '{receive_col}' for Receive, '{type_col}' for Type")
        
        # Display a sample of values in the type column to aid debugging
        print("Sample values in Type column:")
        type_sample = df[type_col].dropna().unique()[:5]  # Show up to 5 unique values
        for val in type_sample:
            print(f"  - {val}")
        
        # Check if the applications file has a date column
        date_col = None
        for col in df.columns:
            if str(col).lower() in ['date', 'day']:
                date_col = col
                print(f"Found date column in applications file: {col}")
                break
        
        # If no specific date column found, assume the data is all for the target date or yesterday
        if not date_col:
            process_date = target_date if target_date else (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
            
            # Sum applications for New Applications - make the matching more robust
            new_apps_df = df[df[type_col].astype(str).str.contains("New", case=False, na=False) & 
                              df[type_col].astype(str).str.contains("Application", case=False, na=False)]
            
            # If no matches found, try a simpler search
            if len(new_apps_df) == 0:
                print("Warning: No exact matches for 'New Applications', trying simplified search")
                new_apps_df = df[df[type_col].astype(str).str.contains("New", case=False, na=False)]
            
            applications_18_64_new = new_apps_df[receive_col].sum()
            
            # Sum applications for Renewals - make the matching more robust
            renewals_df = df[df[type_col].astype(str).str.contains("Renewal", case=False, na=False)]
            applications_18_64_renewals = renewals_df[receive_col].sum()
            
            # Debug - count entries in each category
            print(f"New Applications entries: {len(new_apps_df)}")
            print(f"Renewals entries: {len(renewals_df)}")
            
            print(f"Applications for {process_date}:")
            print(f"  - New Applications: {applications_18_64_new}")
            print(f"  - Renewals: {applications_18_64_renewals}")
            
            # Return with the process date
            return {process_date: (applications_18_64_new, applications_18_64_renewals)}
        else:
            # If we have a date column, process by date
            results = {}
            
            # Convert date column to datetime
            df[date_col] = pd.to_datetime(df[date_col], errors='coerce')
            
            # Filter to target date if specified
            if target_date:
                target_dt = pd.to_datetime(target_date)
                df_filtered = df[df[date_col].dt.date == target_dt.date()]
                if df_filtered.empty:
                    print(f"Warning: No data found for target date {target_date}")
                    # Fall back to using all data
                    df_filtered = df
                else:
                    df = df_filtered
            
            # Group by date
            for date, group in df.groupby(df[date_col].dt.date):
                date_str = date.strftime('%Y-%m-%d')
                
                # Sum applications for New Applications
                new_apps_df = group[group[type_col].astype(str).str.contains("New", case=False, na=False) & 
                                    group[type_col].astype(str).str.contains("Application", case=False, na=False)]
                
                # If no matches found, try a simpler search
                if len(new_apps_df) == 0:
                    print(f"Warning: No exact matches for 'New Applications' on {date_str}, trying simplified search")
                    new_apps_df = group[group[type_col].astype(str).str.contains("New", case=False, na=False)]
                
                applications_18_64_new = new_apps_df[receive_col].sum()
                
                # Sum applications for Renewals
                renewals_df = group[group[type_col].astype(str).str.contains("Renewal", case=False, na=False)]
                applications_18_64_renewals = renewals_df[receive_col].sum()
                
                print(f"Applications for {date_str}:")
                print(f"  - New Applications: {applications_18_64_new}")
                print(f"  - Renewals: {applications_18_64_renewals}")
                
                results[date_str] = (applications_18_64_new, applications_18_64_renewals)
            
            return results
        
    except Exception as e:
        print(f"Error extracting application volumes: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

def calculate_calling_rates(call_data, app_data):
    """
    Calculate the calling rates based on the extracted data.
    
    Args:
        call_data: Dictionary with dates as keys and (call_volumes_18_64, sum_calls_except_18_64) as values
        app_data: Dictionary with dates as keys and (applications_18_64_new, applications_18_64_renewals) as values
    
    Returns:
        Dictionary with dates as keys and (calling_rate_new, calling_rate_renewals) as values
    """
    try:
        results = {}
        
        # Find common dates in both datasets
        common_dates = set(call_data.keys()).intersection(set(app_data.keys()))
        
        if not common_dates:
            print("\nWARNING: No common dates found between call data and application data")
            print("Call data dates:", sorted(list(call_data.keys())))
            print("App data dates:", sorted(list(app_data.keys())))
            
            # If the application data doesn't have dates but we have call dates,
            # assume the app data applies to all call dates
            if len(app_data) == 1 and len(call_data) > 0:
                app_date = list(app_data.keys())[0]
                app_values = app_data[app_date]
                common_dates = set(call_data.keys())
                for date in common_dates:
                    app_data[date] = app_values
                print(f"Applied application data from {app_date} to all call dates: {sorted(list(common_dates))}")
        
        for date in sorted(common_dates):
            call_volumes_18_64, sum_calls_except_18_64 = call_data[date]
            applications_18_64_new, applications_18_64_renewals = app_data[date]
            
            print(f"\nCalculating rates for {date}:")
            print(f"  Call volumes 18-64: {call_volumes_18_64}")
            print(f"  Sum calls except 18-64: {sum_calls_except_18_64}")
            print(f"  Applications new: {applications_18_64_new}")
            print(f"  Applications renewals: {applications_18_64_renewals}")
            
            # Calculate calling rate for new applications
            calling_rate_new = 0
            if applications_18_64_new > 0:
                calling_rate_new = call_volumes_18_64 / applications_18_64_new
            else:
                print(f"  Warning: Zero applications for new (18-64) for {date}")
            
            # Calculate calling rate for renewals
            calling_rate_renewals = 0
            if applications_18_64_renewals > 0:
                calling_rate_renewals = sum_calls_except_18_64 / applications_18_64_renewals
            else:
                print(f"  Warning: Zero applications for renewals for {date}")
            
            print(f"  Calculated calling rates for {date}:")
            print(f"    - New Applications: {calling_rate_new:.4f}")
            print(f"    - Renewals: {calling_rate_renewals:.4f}")
            
            results[date] = (calling_rate_new, calling_rate_renewals)
        
        return results
        
    except Exception as e:
        print(f"Error calculating calling rates: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

def update_output_file(output_path, rate_data):
    """
    Update the output Excel file with the new calling rates.
    
    Args:
        output_path: Path to the output Excel file
        rate_data: Dictionary with dates as keys and (calling_rate_new, calling_rate_renewals) as values
    
    Returns:
        Boolean indicating success or failure
    """
    try:
        # Initialize DataFrame with existing data or create new one
        if os.path.exists(output_path):
            print(f"Output file exists, reading: {output_path}")
            df = pd.read_excel(output_path)
            
            # Convert Date column to datetime if it isn't already
            if 'Date' in df.columns:
                df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
                
            # Check if we have the right columns
            if 'Calling Rate New Applications' not in df.columns:
                df['Calling Rate New Applications'] = 0
            if 'Calling Rate Renewals' not in df.columns:
                df['Calling Rate Renewals'] = 0
        else:
            print(f"Output file does not exist, creating new file: {output_path}")
            df = pd.DataFrame(columns=["Date", "Calling Rate New Applications", "Calling Rate Renewals"])
        
        # Initialize data rows to add
        new_rows = []
        updated_count = 0
        
        # Process each date's data
        for date_str, (calling_rate_new, calling_rate_renewals) in sorted(rate_data.items()):
            date = pd.to_datetime(date_str)
            
            # Check if this date already exists in the DataFrame
            date_exists = False
            
            # Use proper pandas datetime comparison
            if not df.empty and 'Date' in df.columns:
                mask = df['Date'].dt.strftime('%Y-%m-%d') == date.strftime('%Y-%m-%d')
                matching_rows = df[mask]
                
                if not matching_rows.empty:
                    # Update existing row
                    df.loc[mask, 'Calling Rate New Applications'] = calling_rate_new
                    df.loc[mask, 'Calling Rate Renewals'] = calling_rate_renewals
                    updated_count += 1
                    date_exists = True
                    print(f"Updated existing data for {date_str}")
            
            # If date doesn't exist, add a new row
            if not date_exists:
                new_rows.append({
                    "Date": date,
                    "Calling Rate New Applications": calling_rate_new,
                    "Calling Rate Renewals": calling_rate_renewals
                })
                print(f"Adding new data for {date_str}")
        
        # Add any new rows
        if new_rows:
            new_df = pd.DataFrame(new_rows)
            df = pd.concat([df, new_df], ignore_index=True)
        
        # Sort by date
        df = df.sort_values('Date')
        
        # Format the date column to ensure it's just the date (no time)
        df['Date'] = pd.to_datetime(df['Date']).dt.date
        
        # Save the DataFrame to Excel
        df.to_excel(output_path, index=False)
        
        print(f"Output file updated successfully: {output_path}")
        print(f"  - Updated {updated_count} existing entries")
        print(f"  - Added {len(new_rows)} new entries")
        print(f"  - Total entries: {len(df)}")
        
        return True
        
    except Exception as e:
        print(f"Error updating output file: {str(e)}")
        import traceback
        traceback.print_exc()
        return None

def main():
    """Main function to run the daily calling rate calculation."""
    # File paths - UPDATE THESE WITH YOUR ACTUAL PATHS
    call_volume_path = "path/to/call_volume_file.xlsx"
    applications_volume_path = "path/to/applications_volume_file.xlsx"
    output_path = "path/to/output_file.xlsx"
    
    print(f"Starting calling rate calculation...")
    
    # Ask user whether to process historical data or just yesterday's data
    process_type = input("Do you want to process (1) historical data from Jan 2025 onwards or (2) just yesterday's data? Enter 1 or 2: ")
    
    # Extract call volume data - this comes from the daily columns (H onwards)
    if process_type == "1":
        # Process all historical data (all date columns)
        call_data = extract_call_volumes(call_volume_path)
    else:
        # Process just yesterday's data
        yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
        call_data = extract_call_volumes(call_volume_path, yesterday)
    
    if not call_data:
        print("ERROR: Failed to extract call volume data.")
        return
    
    # Extract application volume data - this is your "applications_volume_file.xlsx"
    if process_type == "1":
        # Process all historical data
        app_data = extract_application_volumes(applications_volume_path)
    else:
        # Process just yesterday's data
        yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
        app_data = extract_application_volumes(applications_volume_path, yesterday)
    
    if not app_data:
        print("ERROR: Failed to extract application volume data.")
        return
    
    # Calculate rates
    rate_data = calculate_calling_rates(call_data, app_data)
    if not rate_data:
        print("ERROR: Failed to calculate calling rates.")
        return
    
    # Update output file
    success = update_output_file(output_path, rate_data)
    
    if success:
        print("\n✅ SUCCESS: Calling rates have been calculated and saved.")
        print("    - New Applications Rate: Call Volumes for 18-64 age groups (sum of rows 53, 54, 55)")
        print("                            divided by Applications for 18-64 (New Applications)")
        print("    - Renewals Rate: Sum of calls for other age groups (rows 42-48 + row 56)")
        print("                    divided by Applications for 18-64 (Renewals)")
        print("\nPlease verify the output file to ensure the rates look correct.")
    else:
        print("\n❌ ERROR: Failed to complete the calculation.")

if __name__ == "__main__":
    main()
